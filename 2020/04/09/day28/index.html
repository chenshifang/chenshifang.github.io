<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="陈士方">





<title>Day28 | 陈士方的博客</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


	
<meta name="generator" content="Hexo 4.2.0"></head>


<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo">
				<a href="/">
				陈士方的博客
				</a>
			</div>
			
			
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">目录</a>
                
                    <a class="menu-item" href="/category">分类</a>
                
                    <a class="menu-item" href="/tag">标签</a>
                
                    <a class="menu-item" href="http://chenshifang.gitee.io/chen_resume/" target="_blank" rel="noopener">关于</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>

        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">陈士方的博客</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">目录</a>
                
                    <a class="menu-item" href="/category">分类</a>
                
                    <a class="menu-item" href="/tag">标签</a>
                
                    <a class="menu-item" href="http://chenshifang.gitee.io/chen_resume/" target="_blank" rel="noopener">关于</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">Day28</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">陈士方</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">四月 9, 2020&nbsp;&nbsp;0:00:00</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <ul>
<li>list列表常用方法<br>append：从尾部插入新元素</li>
</ul>
<p>insert：把新元素插入列表，第一个值指定位置，第二个值是元素</p>
<p>count：统计某元素在列表出现的次数</p>
<p>index：返回某个元素的索引</p>
<p>pop：默认移除列表中最后一个元素</p>
<ul>
<li>str字符串常用方法<br>join：用来连接序列中的元素，并且被连接的元素必须都是字符串；他是split方法的逆方法</li>
</ul>
<p>split：用来将字符串分割成序列；join的逆方法</p>
<p>find: 在一个字符串中查找某元素并返回索引，如果没有找到则返回-1，</p>
<p>strip: 去除字符串中的首尾空格</p>
<p>replace：用某元素替换掉字符串中的某元素</p>
<ul>
<li>dict方法<br>clear：清除字典中所有元素</li>
</ul>
<p>frommeys：使用给定的键建立新的字典，每个键都对应一个默认的值None</p>
<p>update：利用一个字典项更新另一个字典，提供的字典中的项会被添加到旧的字典中，如有相同的键则会被覆盖</p>
<p>get：访问字典的方法，如果试图访问字典中不存在的项时不会报错，仅会返回None</p>
<p>zip: 将两个字典合并</p>
<p>pop: 获取对应给定键的值，然后将这个”键-值”对从字典中移除</p>
<p>for循环字典的三种方法<br>values()：返回字典中所有的值<br>keys()：返回字典的所有的key 返回一个序列，序列中保存有字典的所有的键<br>itmes()：返回字典中所有的key = values 返回一个序列，序列中包含有双值子序列</p>
<ul>
<li>集合<br>集合存储的元素无序且不能重复。集合有两种不同的类型，可变集合和不可变集合，可变集合可以添加或删除元素；不可变集合不能被修改。<br>集合必须用Python提供的工厂函数来声明，可变集合使用set函数，不可变集合使用frozenset函数。<br>只有一个元素时，元素后要加逗号</li>
</ul>
<p>set：创建一个可变集合，如果参数为空，创建一个默认的空集合。参数必须是可迭代的，如列表、元祖、字符串等</p>
<p>frozenset：创建一个不可变集合，参数同set()</p>
<p>len：返回集合内元素的个数</p>
<ul>
<li>进程<br>进程是计算机资源分配的最小单位<br>比如，qq、微信等等都是一个进程</li>
</ul>
<ol>
<li>程序并不能单独运行，只有将程序装载到内存中，系统为它分配资源才能运行，这种执行的程序就称之为进程</li>
<li>程序和进程的区别就在于：程序是指令的集合，它是进程运行的静态描述文本；进程是程序的一次执行活动，属于动态概念</li>
<li>在多道编程中，我们允许多个程序同时加载到内存中，在操作系统的调度下，可以实现并发地执行。</li>
<li>进程的出现让每个用户感觉到自己独享CPU，因此，进程就是为了在CPU上实现多道编程而提出的。</li>
<li>进程之间有自己独立的内存，各进程之间不能相互访问</li>
<li>创建一个新线程很简单，创建新进程需要对父进程进行复制</li>
</ol>
<p>进程优点：<br>提供了多道编程，让我们感觉我们每个人都拥有自己的CPU和其他资源，可以提高计算机的利用率</p>
<p>进程的两个重要缺点<br>第一点：进程只能在一个时间干一件事，如果想同时干两件事或多件事，进程就无能为力了。<br>第二点：进程在执行的过程中如果阻塞，即使进程中有些工作不依赖于输入的数据，也将无法执行（例如等待输入，整个进程就会挂起）</p>
<p>进程池<br>复用、提高效率，进程池中最多允许放入五个进程</p>
<p>主进程、子进程<br>主进程就像一台电脑<br>子进程就像一台电脑里的软件</p>
<ul>
<li>线程<br>线程是操作系统调度的最小单位，他被包含在进程之中，是进程中的实际运作单位</li>
</ul>
<ol>
<li>线程是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位</li>
<li>一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务</li>
<li>无论你启多少个线程，你有多少个cpu, Python在执行的时候会淡定的在同一时刻只允许一个线程运行</li>
<li>进程本身是无法自己执行的，要操作cpu，必须创建一个线程，线程是一系列指令的集合</li>
<li>所有在同一个进程里的线程是共享同一块内存空间的，不同进程间内存空间不同</li>
<li>同一个进程中的各线程可以相互访问资源，线程可以操作同进程中的其他线程，但进程仅能操作子进程</li>
<li>两个进程想通信，必须要通过一个中间代理</li>
<li>对主线程的修改可能回影响其他子线程，对主进程修改不会影响其他进程因为进程间内存相互独立，但是同一进程下的线程共享内存</li>
</ol>
<p>守护线程<br>主进程结束后会还可以自动开始<br>例如：资源管理器里面的系统进程，手动结束后，还能自动运行</p>
<ul>
<li>进程和线程的区别<br>1、进程包含线程<br>2、线程共享内存空间<br>3、进程内存是独立的（不可互相访问）<br>4、进程可以生成子进程，子进程之间互相不能互相访问（相当于在父级进程克隆两个子进程）<br>5、在一个进程里面线程之间可以交流。两个进程想通信，必须通过一个中间代理来实现<br>6、创建新线程很简单，创建新进程需要对其父进程进行克隆。<br>7、一个线程可以控制或操作同一个进程里面的其它线程。但进程只能操作子进程。<br>8、父进程可以修改不影响子进程，但不能修改。<br>9、线程可以帮助应用程序同时做几件事</li>
</ul>
<ul>
<li>GIL全局解释器锁<br>作用：在一个进程内，同一时刻只能有一个线程执行<br>说明：python多线程中GIL锁只是在CPU操作时（如：计算）才是串行的，其他都是并行的，所以比串行快很多<br>1）为了解决不同线程同时访问同一资源时，数据保护问题，而产生了GIL<br>2）GIL在解释器的层面限制了程序在同一时间只有一个线程被CPU实际执行，而不管你的程序里实际开了多少条线程<br>3）为了解决这个问题，CPython自己定义了一个全局解释器锁，同一时间仅仅有一个线程可以拿到这个数据<br>4）python之所以会产生这种不好的状况是因为python启用一个线程是调用操作系统原生线程，就是C接口<br>5）但是这仅仅是CPython这个版本的问题，在PyPy，中就没有这种缺陷</li>
</ul>
<ul>
<li>协程<br>又称微线程，一种轻量级线程。<br>协程能保留上一次调用时的状态（即所有局部状态的一个特定组合），每次过程重入时，就相当于进入上一次调用的状态。<br>协程最主要的作用是在单线程的条件下实现并发的效果，但实际上还是串行的（像yield一样）。</li>
</ul>
<p>优点：多任务、效率高<br>缺点：无法利用多核资源</p>
<p>select模型：轮循，效率很低<br>poll模型：和select同理，只不过他突破轮循限制<br>epoll模型：实时切换，就像生成器，可以实现高并发</p>
<ul>
<li>装饰器<br>在不影响原功能的基础上添加新的功能。</li>
</ul>
<ul>
<li>生成器<br>生成器可以理解为一种数据类型，这种数据类型自动实现了迭代器协议（其他数据类型需要调用自己的内置iter方法）<br>在Python中，一边循环，一边计算的机制，称为生成器。</li>
</ul>
<ul>
<li>迭代器</li>
</ul>
<ol>
<li>迭代器是访问集合内元素的方式，迭代器对象从集合的第一个元素开始访问，直到所有的元素都被访问一遍后结束</li>
<li>迭代器仅是一容器对象，它有两个基本方法<br>1）next方法：返回容器的下一个元素<br>2）<strong>iter</strong>方法：返回迭代器自身</li>
</ol>
<ul>
<li>生成器和迭代器的区别<br>在使用生成器时，我们创建一个函数；<br>在使用迭代器时，我们使用内置函数iter()和next()。<br>在生成器中，我们使用关键字‘yield’来每次生成/返回一个对象。生成器中有多少‘yield’语句，你可以自定义。 每次‘yield’暂停循环时，生成器会保存本地变量的状态。<br>而迭代器并不会使用局部变量，它只需要一个可迭代对象进行迭代。使用类可以实现你自己的迭代器，但无法实现生成器。<br>生成器运行速度快，语法简洁，更简单。<br>迭代器更能节约内存。</li>
</ul>
<ul>
<li>面向对象三大特性<br>封装：在类中对数据的赋值、内部调用对外部用户是透明的；把类作为一个容器，里面包含着类的数据和方法</li>
</ul>
<p>继承：一个类可以派生出子类，在这个父类里定义的属性、方法自动被子类继承</p>
<p>多态：多态是面向对象的重要特性,简单点说:“一个接口，多种实现”</p>
<ul>
<li>静态方法<br>作用：静态方法可以更好的组织代码，防止代码变大后变得比较混乱。<br>特性:  静态方法只是名义上归类管理，实际上在静态方法里访问不了类或则实例中的任何属性</li>
</ul>
<ul>
<li>类方法<br>作用：无需实例化直接被类调用<br>特性:  类方法只能访问类变量，不能访问实例变量</li>
</ul>
<ul>
<li>属性方法<br>作用：属性方法把一个方法变成一个属性，隐藏了实现细节,调用时不必加括号直接d.eat即可调用self.eat()方法</li>
</ul>
<ul>
<li>魔法方法<br><strong>new</strong>  :  先于<strong>init</strong>方法，每生成一个实例执行一次，<strong>new</strong> 类方法创建实例对象<br><strong>init</strong> :  <strong>init</strong>方法每生成一个实例就会执行一次，初始化实例对象<br><strong>call</strong> :   后与<strong>init</strong>方法，C()() 使用类再加一个括号调用， C为类名称<br><strong>del</strong>  :   析构方法，删除无用的内存对象（当程序结束会自动自行析构方法）</li>
</ul>
<ul>
<li>深浅拷贝<br>浅拷贝：不管多么复杂的数据结构，浅拷贝都只会copy一层</li>
</ul>
<p>深拷贝: 深拷贝会完全复制原变量相关的所有数据，在内存中生成一套完全一样的内容，我们对这两个变量中任意一个修改都不会影响其他变量</p>
<ul>
<li>上下文管理</li>
</ul>
<ol>
<li>with是一种上下文管理协议，目的在于从流程图中把 try,except 和finally 关键字和资源分配释放相关代码统统去掉，简化try….except….finlally的处理流程。</li>
<li>所以使用with处理的对象必须有enter()和exit()这两个方法<br>　　1）with通过enter方法初始化（enter方法在语句体执行之前进入运行）<br>　　2）然后在exit中做善后以及处理异常（exit()方法在语句体执行完毕退出后运行）</li>
</ol>
<ul>
<li>高阶函数<br>Map是对序列根据设定条件进行操作后返回他设置的是操作方法</li>
</ul>
<p>filter()函数可以对序列做过滤处理</p>
<p>reduce()函数即为化简函数，它的执行过程为：每一次迭代，都将上一次的迭代结果与下一个元素一同传入二元func函数中去执行。</p>
<p>sorted对字典排序</p>

        </div>

        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/%E7%AC%94%E8%AE%B0/"># 笔记</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
            
            <a class="next" rel="next" href="/2020/04/08/day27/">Day27</a>
            
        </section>


    </article>
</div>

        </div>
        <footer id="footer" class="footer">
    <div class="copyright">
        <span>© 陈士方 | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>
			
    </div>
	
<iframe src="https://zhanyuzhang.github.io/lovely-cat/cat.html" frameborder="0" id="catIframe"></iframe>

</body>


<style>
#catIframe {
position: fixed;
width: 400px;
/* padding: 50px 0px; */
top: 80%;
left: 10%;
transform: translate(-68%, -50%);
}

</style>
</html>
